# Dead Code Insertion with Variable Conditions

This is a project done for the Automated Software Testing course at ETH ZÃ¼rich.

## Abstract
Missed compiler optimizations reveal performance bugs in compilers. Using dead code elimination (DCE) Theodoridis et al. were able to detect performance bugs by inserting "optimization markers" into randomly generated C programs and compiling them with different versions and options. In this paper we extend this approach by inserting dead code into the programs by adding unsatisfiable if-statements. We performed different experiments with variations of our method. Each experiment either adds additional markers to each basic block and/or keeps track of local and global or only global variables only. With each experiment we were able to detect interesting  cases which  dead  was not able to. In one particular experiment our approach was able to detect 33% more cases than  dead. We hope our extension leads to a better understanding in the analysis of DCE.
## Documentation
The implementation computes the cases that gave the best results in the evaluation. Our tool extends [dead](https://github.com/DeadCodeProductions/dead) with a `dc_inserter` file that inserts dead code into programs to generate more interesting cases.
### Getting Started
The program is best run in a docker container. Please consult [dead](https://github.com/DeadCodeProductions/dead) to get the docker image.  Build the image and run the container. Once in the container delete all files and clone this repository. This repository contains the extended `dead` tool.

If you plan to use the tool multiple times we recommend to create a new docker image from this container. This can be done with `docker commit`. Consult the [docker documentation](https://docs.docker.com/engine/reference/commandline/commit/) for more detailed information about this command.

Now you can run the docker image with the following command:
`docker run --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -it -v deadpersistent:/persistent <IMAGE_NAME>`.

The flags:`--cap-add=SYS_PTRACE --security-opt seccomp=unconfined`are needed to be able to run `gdb` in the container.

The main changes that we made in `dead` is in the `generator.py` file. There `CSmith` programs are generated, instrumented and checked for interestingness. Our tool checks the interstingness of two programs. First the unextended programs are checked and then we run these programs through the `dc_inserter.py` to insert dead code and check the interestingness of the modified programs. The results of interestingness are then stored in `cases/data.csv` that can be used for further evaluation.

For our data we ran the tool with the following command:
`python3 generator.py --amount 1 --interesting --targets gcc trunk 1 2 3 s --additional-compilers gcc releases/gcc-11.2.0 gcc releases/gcc-10.3.0 gcc releases/gcc-9.4.0 gcc releases/gcc-8.5.0 gcc releases/gcc-7.5.0 -acdol 1 2 3 s --output-directory /home/dead/AST-Project-Carnet-Neffj/dead/generator_output`

This checks the interestingness using different `gcc` versions. For more detailed info check the documentation for `dead`.

WARNING: Don't run it in parallel. `dc_inserter.py` makes use of temporary files. It is not tested to be run in parallel.

### Implementation Details (dc_inserter.py)
#### entrance() / main()
It's the starting point of the program where `entrance()` is for calls from the outside (`dead`) and `main()` for standalone execution. The standalone execution only handles the case that is currently in the `tmp/` directory.
#### precompute()
This function makes the program ready for the `gdb` run.

 - It transforms `void DCEMarkerx_(void);` to `void DCEMarker{}_(void){}` to provide clear function definitions.
 - It creates a `command_file.txt`in `tmp/`that contains the list of commands that are run at the launch of `gdb`.
 - It sets the breakpoints at each marker
 - Gets global variable names to create the print statements for global variables.
 - Set up logging functionalities of `gdb`
#### run_gdb()
This function simply runs the `gdb_script.sh` script which executes the program under `gdb`. 
#### eval_log()
This function evaluates the logfile generated by `gdb` before. It parses the file and gathers the variable values achieved during execution and stores them into a nested dictionary.
#### unsatConditionGenerator()
Takes the gathered data by `eval_log()` and generates a string that is the unsatisfiable condition that will be inserted. The condition is created by taking a random value that is never achieved by a variable during execution making the condition unsat. Each live variable gives such a condition and every condition is connected with the `OR` operator.
#### instrument_code()
This function takes the code and the condition and inserts the dead code into the program.
#### Return
After adding our dead code the program is sent back to `dead` for the interestingness evaluation.
